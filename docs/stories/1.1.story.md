# Story 1.1: Define Semantic Group Data Model

**Status:** Approved

## Story

As a Developer,
I want a clear and structured data model for Semantic Groups,
so that the system can consistently parse, store, and use group configurations.

## Acceptance Criteria

1.  Define the structure for a `SemanticGroup` configuration, including detailed fields for `name`, `filter`, `versionPolicy`, `grouping`, and `lanes`.
2.  Define the structure for a `SemanticEntity`, including a unique identifier and a reference to its source file(s).
3.  Document the data models as TypeScript interfaces in the shared types directory.

## Dev Notes

### Data Models

The following TypeScript interfaces are derived from `docs/group-config-sample.json` and `docs/architecture/data-models.md` to represent the full configuration structure.

```typescript
// --- Filter Interfaces ---

type TFilterOperation = "eq" | "regex" | "range";
type TLogicalOperator = "AND" | "OR" | "NOT";

interface IFieldFilter {
  field: string;
  op: TFilterOperation;
  value?: string | number;
  min?: string | number;
  max?: string | number;
}

interface ILogicalFilter {
  operator: TLogicalOperator;
  operands: Array<ILogicalFilter | IFieldFilter>;
}

type TFilter = ILogicalFilter | IFieldFilter;

// --- Version Policy Interface ---

interface IVersionPolicy {
  mode: "latestOnBranch"; // Can be extended later
  branch: string;
}

// --- Grouping Interfaces ---

interface IGroupingRule {
  match: Record<string, string>;
  strategy: "per_page" | "per_file"; // Can be extended later
  pageRange?: [number, number];
  entityNameTemplate: string;
}

interface IGrouping {
  strategy: "composite"; // Can be extended later
  rules: IGroupingRule[];
}

// --- Lane Interfaces ---

type TModality = "image" | "text" | "audio";
type TRetentionPolicy = "keep_last_n" | "expire_after";
type TVisibilityScope = "shared" | "public" | "internal";

interface IEmbedder {
  model: string;
  uri: string;
  digest: string;
  parameters: Record<string, any>;
  modality: TModality;
  postProcessing?: string[];
  tokenizerUri?: string;
  tokenizerDigest?: string;
}

interface IIndexConfig {
  chunkSize?: number;
  overlap?: number;
  storeVectors: boolean;
  storeMetadata: boolean;
  unit?: "seconds";
}

interface IVisibility {
  scope: TVisibilityScope;
  teams?: string[];
}

interface IRetention {
  policy: TRetentionPolicy;
  n?: number;
  maxAge: string; // ISO 8601 duration format, e.g., "P90D"
}

interface ILane {
  id: string;
  displayName: string;
  embedder: IEmbedder;
  indexConfig: IIndexConfig;
  tags: string[];
  visibility: IVisibility;
  retention: IRetention;
}

// --- Top-Level Semantic Group Interface ---

interface IMetadata {
  ownerTeam: string;
  labels: Record<string, string>;
}

interface ISemanticGroup {
  name: string;
  description: string;
  filter: TFilter;
  versionPolicy: IVersionPolicy;
  grouping: IGrouping;
  lanes: ILane[];
  metadata: IMetadata;
}

// --- Semantic Entity Interface ---
// [Source: docs/architecture/data-models.md]

interface ISemanticEntity {
  id: string;                // canonical, stable across versions
  sourceRefs: Array<{
    connectorType: "lakefs" | "git";
    repository: string;
    ref: string; // commit/tag/branch
    path: string;
  }>;
  metadata: Record<string, any>;
}
```

### File Locations

The data models will be defined in one or more files within the `packages/shared/src/types/` directory. [Source: docs/architecture/source-tree.md]

### Testing Requirements

Unit tests will be created for any validation logic associated with these data models, ensuring 80% code coverage. [Source: docs/architecture/testing-strategy.md]

## Tasks / Subtasks

1.  **(AC: 1, 3)** Create a new file `packages/shared/src/types/semantic-group.types.ts` to define all the new interfaces (`ISemanticGroup`, `ILane`, `IFilter`, etc.).
2.  **(AC: 2, 3)** Create a new file `packages/shared/src/types/semantic-entity.types.ts` to define the `ISemanticEntity` interface.
3.  **(AC: 1, 2)** Add TSDoc comments to all interfaces and properties to document their purpose.
4.  **(AC: 1, 2)** Create unit tests for any validation functions that might be created for these complex types, particularly for the `TFilter` structure.
