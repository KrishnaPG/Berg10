# Database Schema

*(Conceptual, as the primary "database" is the `semantic-repo` filesystem structure)*

1.  **`semantic-repo` Structure (Single Source of Truth):**
    *   `.semantic/`
        *   `version`: File containing the semantic-repo schema version.
        *   `index/`
            *   `sha256/`: Directory for immutable index blobs, named by their SHA256 hash (e.g., `a1b2c3d4...embed`). **This directory can be a standard folder or a mount point for external object storage like S3 or a LakeFS data lake.**
            *   `lanes/`
                *   `<lane_id>/`: one sub-folder per lane (each unique model config) from all `<group_name>/config.json` files
                    *   `manifest.jsonl`: The authoritative, append-only log of index records generated by this model configuration.
        *   `groups/`
            *   `<group_name>/`
                *   `config.json`: The `SemanticGroup` configuration.
    *   `.git/`: Standard Git metadata for versioning the `semantic-repo` configurations and manifests. The `index/` folder that contains the blobs may be ignored from git when it is an S3 or LakeFS mount-point. When the `index/` is just a local file system path, then it can be included in the git. In such case Git LFS may have to be enabled if the blobs sizes are large.

2.  **Vector Database (Secondary Index / Hot Store):**
    *   The Vector DB is considered a secondary, performance-oriented data store.
    *   Its state is derived entirely from the data in the `semantic-repo`. For local-only scenarios, the DB must be explicitly populated from the blob store. In enterprise deployments, the `semantic-repo` can mounted as data lake source for compatible databases (e.g. Dremio), or run a cron or schedule-based ingestion into vector databases (e.g. AirByte).
    *   If the Vector DB becomes corrupted or is lost, it can be fully rebuilt from the `semantic-repo`.

Notes:
- Use `.semantic/index/sha256/<first-three-chars>/<next-three-chars>/<next-three-chars>/<rest-of-hash>` as the single, immutable blob store.
- `.semantic/index/lanes/<lane_id>` Per-lane folders only contain their `manifest.jsonl` (plus optional small metadata); they never contain the actual blobs.
  - Manifest size remains proportional to one model’s indexing jobs, not the cross product of all models.
  - Deleting or deprecating a lane is `rm -rf <lane_id folder>`.
- Security is achievable via ACL on the manifest (or `lane_id` folder), not on the blob path.

`LaneId` rules of thumb:
- The **lane id** is the stable namespace.
- Anything that alters the semantic meaning of the lane (model, modality, grouping) → **create a new lane id** to keep history side-by-side.
- Only non-semantic tuning (confidence threshold, minor overlap delta) is allowed to reuse the lane id; the manifest keeps both generations, and retention policy decides when older blobs are garbage-collected.


