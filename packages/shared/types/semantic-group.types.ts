// --- Filter Interfaces ---

/**
 * Defines the possible operations for a field-based filter.
 * - `eq`: Equals
 * - `regex`: Regular expression match
 * - `range`: A numeric or date range
 */
export type TFilterOperation = "eq" | "regex" | "range";

/**
 * Defines the logical operators to combine filters.
 */
export type TLogicalOperator = "AND" | "OR" | "NOT";

/**
 * Represents a filter on a single field.
 */
export interface IFieldFilter {
  /** The name of the field to filter on (e.g., "mime_type", "size"). */
  field: string;
  /** The operation to perform on the field. */
  op: TFilterOperation;
  /** The value for 'eq' or 'regex' operations. */
  value?: string | number;
  /** The minimum value for a 'range' operation. */
  min?: string | number;
  /** The maximum value for a 'range' operation. */
  max?: string | number;
}

/**
 * Represents a logical combination of multiple filters.
 */
export interface ILogicalFilter {
  /** The logical operator to apply to the operands. */
  operator: TLogicalOperator;
  /** An array of filters to combine. */
  operands: Array<ILogicalFilter | IFieldFilter>;
}

/**
 * A union type representing any possible filter structure.
 */
export type TFilter = ILogicalFilter | IFieldFilter;

// --- Version Policy Interface ---

/**
 * Defines the strategy for selecting which version of source files to process.
 */
export interface IVersionPolicy {
  /** The mode of version selection. Currently supports 'latestOnBranch'. */
  mode: "latestOnBranch"; // Can be extended later
  /** The specific branch to track for the latest version. */
  branch: string;
}

// --- Grouping Interfaces ---

/**
 * Defines a rule for how to group source files into Semantic Entities.
 */
export interface IGroupingRule {
  /** A condition to determine if this rule applies to a source file (e.g., based on mime_type). */
  match: Record<string, string>;
  /** The strategy for creating entities from the matched file. */
  strategy: "per_page" | "per_file"; // Can be extended later
  /** For 'per_page' strategy, specifies the range of pages to process. */
  pageRange?: [number, number];
  /** A template for naming the created entities, using placeholders like {{fileName}}. */
  entityNameTemplate: string;
}

/**
 * Defines the overall grouping strategy for a Semantic Group.
 */
export interface IGrouping {
  /** The main grouping strategy. Currently supports 'composite'. */
  strategy: "composite"; // Can be extended later
  /** An array of rules to apply for a 'composite' strategy. */
  rules: IGroupingRule[];
}

// --- Lane Interfaces ---

/**
 * The modality of the data being processed by an embedder.
 */
export type TModality = "image" | "text" | "audio";

/**
 * The policy for retaining generated index versions.
 */
export type TRetentionPolicy = "keep_last_n" | "expire_after";

/**
 * The visibility scope for the data generated by a lane.
 */
export type TVisibilityScope = "shared" | "public" | "internal";

/**
 * Configuration for an AI model embedder.
 */
export interface IEmbedder {
  /** The name of the model (e.g., "ultralytics/yolov8x"). */
  model: string;
  /** The URI pointing to the model resource. */
  uri: string;
  /** The digest (e.g., SHA256 hash) to verify the model's integrity. */
  digest: string;
  /** A set of key-value parameters for the model. */
  parameters: Record<string, any>;
  /** The data modality the model operates on. */
  modality: TModality;
  /** An array of post-processing steps to apply. */
  postProcessing?: string[];
  /** The URI for a tokenizer, if required by the model. */
  tokenizerUri?: string;
  /** The digest for the tokenizer. */
  tokenizerDigest?: string;
}

/**
 * Configuration for the indexing process.
 */
export interface IIndexConfig {
  /** The size of chunks to break data into before embedding. */
  chunkSize?: number;
  /** The overlap between chunks. */
  overlap?: number;
  /** Whether to store the generated vector embeddings. */
  storeVectors: boolean;
  /** Whether to store associated metadata. */
  storeMetadata: boolean;
  /** The unit for chunking, if applicable (e.g., "seconds" for audio). */
  unit?: "seconds";
}

/**
 * Defines the visibility and access control for a lane's output.
 */
export interface IVisibility {
  /** The general scope of visibility. */
  scope: TVisibilityScope;
  /** A list of teams with access for 'shared' scope. */
  teams?: string[];
}

/**
 * Defines the retention policy for a lane's generated artifacts.
 */
export interface IRetention {
  /** The retention policy type. */
  policy: TRetentionPolicy;
  /** For 'keep_last_n', the number of versions to keep. */
  n?: number;
  /** The maximum age of artifacts, in ISO 8601 duration format (e.g., "P90D"). */
  maxAge: string;
}

/**
 * A 'lane' represents a complete, independent indexing pipeline for a Semantic Group.
 */
export interface ILane {
  /** A unique identifier for the lane. */
  id: string;
  /** A user-friendly name for the lane. */
  displayName: string;
  /** The embedder configuration for this lane. */
  embedder: IEmbedder;
  /** The indexing configuration for this lane. */
  indexConfig: IIndexConfig;
  /** A list of tags for categorization. */
  tags: string[];
  /** The visibility settings for this lane. */
  visibility: IVisibility;
  /** The retention policy for this lane. */
  retention: IRetention;
}

// --- Top-Level Semantic Group Interface ---

/**
 * General metadata for the Semantic Group.
 */
export interface IMetadata {
  /** The team that owns this group configuration. */
  ownerTeam: string;
  /** A set of key-value labels for categorization and policy enforcement. */
  labels: Record<string, string>;
}

/**
 * The root interface for a Semantic Group configuration.
 */
export interface ISemanticGroup {
  /** The unique name of the group. */
  name: string;
  /** A user-friendly description of the group's purpose. */
  description: string;
  /** The filter that defines which source files belong to this group. */
  filter: TFilter;
  /** The policy for selecting file versions. */
  versionPolicy: IVersionPolicy;
  /** The rules for grouping files into entities. */
  grouping: IGrouping;
  /** An array of independent indexing pipelines (lanes) to run on the group. */
  lanes: ILane[];
  /** Additional metadata about the group. */
  metadata: IMetadata;
}
